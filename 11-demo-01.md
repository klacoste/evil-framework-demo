# Demo 1: Counter with Derived State

## Goal

Build a minimal demo application using the new framework to validate the core concepts:

* State domains
* Commands as the only write path
* Selectors for derived state
* Explicit UI subscriptions
* Predictable re-rendering

This demo should not include services, side effects, or async behavior. It exists solely to confirm that state ownership, updates, and rendering work together coherently.

---

## Tech Stack

The demo must use the following stack:

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework implemented as part of this demo
* **Styling:** Plain CSS or inline styles (no CSS frameworks)
* **Testing:** None required for this demo

Do not introduce additional libraries unless strictly necessary.

---

## Functional Requirements

### Counter Behavior

The application displays a single counter with:

* A numeric value
* Buttons to:

  * Increment
  * Decrement
  * Reset to zero

The UI must also display derived state:

* Whether the current value is even or odd
* Whether the value is positive, negative, or zero

---

## Architectural Requirements

### State Domain

Create a `CounterDomain` with:

#### State shape

```js
{
  value: number
}
```

Initial state:

```js
{ value: 0 }
```

#### Commands (write operations)

* `increment(state)`
* `decrement(state)`
* `reset(state)`

Each command:

* Is synchronous
* Is pure
* Returns the next state
* Performs no side effects

#### Selectors (read operations)

* `getValue(state) -> number`
* `isEven(state) -> boolean`
* `sign(state) -> "positive" | "negative" | "zero"`

Selectors must be:

* Pure functions
* Derived only from domain state
* Used by UI components for subscription

---

## UI Requirements

### Rendering

Use React for rendering (function components only).

Create a `CounterView` component that:

* Subscribes explicitly to selectors using `useSelector`
* Does **not** access domain state directly
* Does **not** perform side effects

Example (illustrative, not prescriptive):

```js
const value = useSelector(CounterDomain.selectors.getValue);
const isEven = useSelector(CounterDomain.selectors.isEven);
const sign = useSelector(CounterDomain.selectors.sign);
```

The UI should display:

* Current value
* Even/odd status
* Sign status

---

### User Interaction

Buttons must call domain commands directly:

```js
<button onClick={CounterDomain.commands.increment}>+</button>
<button onClick={CounterDomain.commands.decrement}>-</button>
<button onClick={CounterDomain.commands.reset}>Reset</button>
```

No intermediate handlers or services are required for this demo.

---

## Framework Primitives Required

The demo must implement (or stub) the following framework APIs:

### `createDomain(config)`

Responsible for:

* Storing domain state
* Exposing commands
* Exposing selectors
* Notifying subscribers on state changes

### `useSelector(selector)`

Responsible for:

* Subscribing a component to a selector
* Triggering re-render when selector output changes
* Avoiding re-render when selector output is unchanged

Selector comparison rules for this demo:

* Primitive values use strict equality (`===`)
* No deep comparison required

---

## Non-Goals

The demo must **not** include:

* Application services
* Effect handlers
* Async logic
* Routing
* Persistence
* Optimizations beyond correctness

---

## Success Criteria

This demo is considered complete when:

* Clicking buttons updates state correctly
* Only components using changed selectors re-render
* Derived state updates correctly
* No side effects occur during render
* State updates are easy to trace and reason about

If this demo feels awkward or requires workarounds, the framework design should be revisited before proceeding to more complex demos.

---

## Notes for the Agent

* Favor explicitness over terseness
* Avoid clever abstractions
* Keep implementation minimal but readable
* Stop once the demo works and is easy to understand
