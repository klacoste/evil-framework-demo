# Demo 2: Async Data Fetch with Split Domains

## Goal

Extend the framework to support **asynchronous workflows** by introducing:

* Application services
* Effect handlers
* Explicit process state management

This demo validates that async behavior, side effects, and state updates can be coordinated **without mixing entity state and process state**, and without relying on UI lifecycle hooks or implicit behavior.

---

## Tech Stack

The demo must use the following stack:

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework implemented as part of this demo
* **Async Simulation:** `setTimeout` or mocked `fetch`
* **Styling:** Plain CSS or inline styles (no CSS frameworks)
* **Testing:** None required for this demo

No additional libraries should be introduced unless strictly necessary.

---

## Functional Requirements

### User Profile Loader

The application displays:

* A button: **“Load User”**
* A status indicator:

  * Idle
  * Loading
  * Error
* A user profile view on success
* An error message with a retry option on failure

---

## Architectural Requirements

This demo must use **two separate state domains**.

---

## State Domain 1: UserDomain (Entity State)

### State Shape

```js
{
  user: null | {
    id: number,
    name: string,
    email: string
  }
}
```

Initial state:

```js
{
  user: null
}
```

### Commands

* `setUser(state, user)`
* `clearUser(state)` (optional)

Commands must:

* Be synchronous and pure
* Return the next state
* Perform no side effects

### Selectors

* `getUser(state)`
* `hasUser(state)`

Selectors must be pure and used by UI components for subscription.

---

## State Domain 2: UserLoadDomain (Process State)

### State Shape

```js
{
  status: "idle" | "loading" | "error",
  error: null | string
}
```

Initial state:

```js
{
  status: "idle",
  error: null
}
```

### Commands

* `setIdle(state)`
* `setLoading(state)`
* `setError(state, error)`

Commands must:

* Be synchronous and pure
* Return the next state
* Perform no side effects

### Selectors

* `getStatus(state)`
* `isIdle(state)`
* `isLoading(state)`
* `hasError(state)`
* `getError(state)`

---

## Effect Handlers

Create an effect handler module responsible for external interaction.

### API Effect

Implement a mock API function:

```js
Effects.api.fetchUser()
```

Behavior:

* Returns a Promise
* Resolves with mock user data **or**
* Rejects with an error (randomized or configurable)

This function must:

* Contain no state logic
* Be callable from application services only

---

## Application Service

Create a `UserService` responsible for coordinating the workflow.

### `loadUser()`

Behavior:

1. Set load state to loading
2. Call `Effects.api.fetchUser()`
3. On success:

   * Update `UserDomain` with user data
   * Set load state to idle
4. On failure:

   * Set load state to error

Illustrative flow (not prescriptive syntax):

```js
UserLoadDomain.commands.setLoading();

try {
  const user = await Effects.api.fetchUser();
  UserDomain.commands.setUser(user);
  UserLoadDomain.commands.setIdle();
} catch (error) {
  UserLoadDomain.commands.setError(error.message);
}
```

All async logic must live in the service — **never in UI components**.

---

## UI Requirements

### Rendering

Create a `UserProfileView` component that:

* Subscribes explicitly to selectors from **both domains**
* Renders based on load status and user presence
* Does not perform side effects
* Does not call effects directly

Expected UI behavior:

* **Idle + no user:** Show “Load User” button
* **Loading:** Show loading indicator
* **Idle + user:** Show user profile
* **Error:** Show error message + retry button

---

### User Interaction

* Clicking “Load User” calls `UserService.loadUser()`
* Clicking “Retry” calls `UserService.loadUser()`
* No UI-level async logic is allowed

---

## Framework Primitives Required

In addition to Demo 1 primitives, this demo must support:

### Application Services

* Services are plain objects or modules
* Services may be async
* Services may call effect handlers
* Services may invoke domain commands
* Services must not access UI or DOM APIs

### Effect Handlers

* Encapsulate async or external logic
* Are stateless
* Are easily replaceable or mockable

---

## Non-Goals

The demo must **not** include:

* Routing
* Global error handling
* Caching
* Optimistic updates
* Analytics
* Offline support

Those concerns are intentionally deferred.

---

## Success Criteria

This demo is complete when:

* Entity state and process state are clearly separated
* Loading, success, and error states behave correctly
* UI re-renders only when subscribed selector values change
* All async logic lives in services
* All side effects live in effect handlers
* Rendering remains side-effect-free
* The data flow is easy to trace end-to-end

If this demo feels awkward or requires workarounds, the framework design should be revisited before proceeding to later demos.

---

## Notes for the Agent

* Do not merge process state into entity domains
* Do not move async logic into components
* Favor clarity over abstraction
* Keep services explicit and linear
* Stop once the demo works and is easy to understand
