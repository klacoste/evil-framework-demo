# Demo 2: Async Data Fetch with Loading and Error States

## Goal

Extend the framework to support **asynchronous workflows** by introducing:

* Application services
* Effect handlers
* Explicit loading and error state management

This demo validates that async behavior, side effects, and state updates can be coordinated **without relying on UI lifecycle hooks or implicit behavior**.

---

## Tech Stack

The demo must use the following stack:

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework implemented as part of this demo
* **Async Simulation:** `setTimeout` or mocked `fetch`
* **Styling:** Plain CSS or inline styles (no CSS frameworks)
* **Testing:** None required for this demo

No additional libraries should be introduced unless strictly necessary.

---

## Functional Requirements

### User Profile Loader

The application displays:

* A button: **“Load User”**
* A status indicator:

  * Idle
  * Loading
  * Error
* A user profile view on success
* An error message with a retry option on failure

---

## Architectural Requirements

### State Domain

Create a `UserDomain` with the following state shape:

```js
{
  user: null | {
    id: number,
    name: string,
    email: string
  },
  status: "idle" | "loading" | "error",
  error: null | string
}
```

Initial state:

```js
{
  user: null,
  status: "idle",
  error: null
}
```

#### Commands

* `setLoading(state)`
* `setUser(state, user)`
* `setError(state, error)`
* `reset(state)` (optional, used for retry)

Each command must:

* Be synchronous and pure
* Return the next state
* Perform no side effects

---

### Selectors

Provide selectors for:

* `getUser(state)`
* `getStatus(state)`
* `getError(state)`
* `isLoading(state)`
* `hasError(state)`

Selectors must be pure and used by UI components for subscription.

---

## Effect Handlers

Create an effect handler module responsible for external interaction.

### API Effect

Implement a mock API function:

```js
Effects.api.fetchUser()
```

Behavior:

* Returns a Promise
* Resolves with mock user data **or**
* Rejects with an error (randomized or configurable)

This function must:

* Contain no state logic
* Be callable from application services only

---

## Application Service

Create a `UserService` responsible for coordinating the workflow.

### `loadUser()`

Behavior:

1. Set domain state to loading
2. Call `Effects.api.fetchUser()`
3. On success:

   * Update domain with user data
4. On failure:

   * Update domain with error state

Illustrative flow (not prescriptive syntax):

```js
UserDomain.commands.setLoading();

try {
  const user = await Effects.api.fetchUser();
  UserDomain.commands.setUser(user);
} catch (error) {
  UserDomain.commands.setError(error.message);
}
```

All async logic must live in the service — **never in UI components**.

---

## UI Requirements

### Rendering

Create a `UserProfileView` component that:

* Subscribes explicitly to domain selectors
* Renders based on `status`
* Does not perform side effects
* Does not call effects directly

Expected UI behavior:

* **Idle:** Show “Load User” button
* **Loading:** Show loading indicator
* **Success:** Show user profile
* **Error:** Show error message + retry button

---

### User Interaction

* Clicking “Load User” calls `UserService.loadUser()`
* Clicking “Retry” calls `UserService.loadUser()` again
* No UI-level async logic is allowed

---

## Framework Primitives Required

In addition to Demo 1 primitives, this demo must support:

### Application Services

* Services are plain objects or modules
* Services may be async
* Services may call effect handlers
* Services may invoke domain commands
* Services must not access UI or DOM APIs

### Effect Handlers

* Encapsulate async or external logic
* Are stateless
* Are easily replaceable or mockable

---

## Non-Goals

The demo must **not** include:

* Routing
* Global error handling
* Caching
* Optimistic updates
* Analytics
* Offline support

Those concerns are intentionally deferred.

---

## Success Criteria

This demo is complete when:

* Loading, success, and error states behave correctly
* UI re-renders only when subscribed selector values change
* All async logic lives in services
* All side effects live in effect handlers
* Rendering remains side-effect-free
* The data flow is easy to trace end-to-end

If async behavior feels awkward or requires workarounds, the service or effect abstractions should be revisited before proceeding to later demos.

---

## Notes for the Agent

* Do not move async logic into components
* Favor clarity over abstraction
* Keep services explicit and linear
* Stop once the demo works and is easy to understand
