# Demo 3: Coordinated Multi-Domain Workflow (Framework-First, Atomic)

## Goal

Validate the framework’s ability to support a **non-trivial, atomic user workflow** that spans:

* Multiple state domains
* Multiple application services
* Multiple effect handlers

This demo intentionally tightens constraints and removes earlier conveniences. It must be implemented **from the framework specification**, not by copying or extending patterns from Demo 1 or Demo 2.

If something worked previously but violates the framework rules, it must be removed or reworked.

---

## Core Principle (Read This First)

**This demo is not incremental.**

* Do **not** rely on implementation shortcuts from earlier demos
* Do **not** assume UI components can “help” orchestrate behavior
* Do **not** merge responsibilities to reduce boilerplate

Every layer must operate strictly within its contract.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework (authoritative spec)
* **Async Simulation:** Mocked APIs (`setTimeout` or fake fetch)
* **Styling:** Plain CSS or inline styles
* **Testing:** None required

No additional libraries are allowed.

---

## Functional Scenario

### “User Dashboard Initialization”

When the user clicks **“Open Dashboard”**, the application must:

1. Load the authenticated user
2. Load that user’s notifications
3. Load that user’s preferences
4. Render a dashboard **only when all required data is ready**

This workflow is treated as **atomic** from the UI’s point of view.

Failures must be handled explicitly and visibly.

---

## Architectural Requirements

This demo must use **four distinct state domains**, each with a single responsibility.

Entity state and process state **must not be mixed**.

---

## State Domains

### 1. AuthUserDomain (Entity State)

```js
{
  user: null | { id, name }
}
```

Commands:

* `setUser(state, user)`
* `clearUser(state)`

Selectors:

* `getUser`
* `hasUser`

---

### 2. NotificationsDomain (Entity State)

```js
{
  notifications: []
}
```

Commands:

* `setNotifications(state, list)`
* `clearNotifications(state)`

Selectors:

* `getNotifications`
* `hasNotifications`

---

### 3. PreferencesDomain (Entity State)

```js
{
  preferences: null | { theme, layout }
}
```

Commands:

* `setPreferences(state, prefs)`
* `clearPreferences(state)`

Selectors:

* `getPreferences`
* `hasPreferences`

---

### 4. DashboardLoadDomain (Process State)

```js
{
  status: "idle" | "loading" | "error",
  error: null | string
}
```

Commands:

* `setIdle`
* `setLoading`
* `setError`

Selectors:

* `getStatus`
* `isLoading`
* `hasError`
* `getError`

---

## Effect Handlers

All external interactions must live here.

Required effects:

```js
Effects.api.fetchUser()
Effects.api.fetchNotifications(userId)
Effects.api.fetchPreferences(userId)
```

Rules:

* No state access
* No orchestration
* No retries
* No UI knowledge

### Mock API Behavior (Explicit)

* Fixed delay (e.g. 500–800ms)
* Deterministic failure mode (e.g. fail every Nth call or via a toggle)
* No randomness by default
* Deterministic mock state may live inside the effect handler for reproducibility

The goal is **reproducibility**, not realism.

---

## Application Service

### DashboardService

This service owns the **entire workflow**.

It is the **only place** where cross-domain coordination is allowed.

#### `initializeDashboard()`

Required behavior:

1. Set `DashboardLoadDomain` → loading
2. Fetch user
3. Fetch notifications and preferences (may be parallel)
4. **Only after all fetches succeed**:

   * Populate all entity domains
5. Set load state → idle

#### Atomicity Rules

* The workflow is **all-or-nothing**
* Entity domains must **not** be partially populated
* If any step fails:

  * No entity domains are updated
  * Existing entity data (if any) is cleared
  * Load state is set to error

Illustrative flow (not prescriptive syntax):

```js
DashboardLoadDomain.commands.setLoading();

try {
  const user = await Effects.api.fetchUser();
  const [notifications, preferences] = await Promise.all([
    Effects.api.fetchNotifications(user.id),
    Effects.api.fetchPreferences(user.id),
  ]);

  AuthUserDomain.commands.setUser(user);
  NotificationsDomain.commands.setNotifications(notifications);
  PreferencesDomain.commands.setPreferences(preferences);

  DashboardLoadDomain.commands.setIdle();
} catch (err) {
  AuthUserDomain.commands.clearUser();
  NotificationsDomain.commands.clearNotifications();
  PreferencesDomain.commands.clearPreferences();

  DashboardLoadDomain.commands.setError(err.message);
}
```

This logic **must not** exist anywhere else.

---

## UI Requirements

### DashboardView

The UI layer must:

* Subscribe **only** via selectors
* Render strictly based on state
* Emit intent only

#### Button Behavior (Explicit)

* **Open Dashboard** button:

  * Visible when status is `idle` or `error`
  * Disabled or hidden while `loading`
  * Serves as both **initial load** and **retry**

Allowed action:

```js
<button onClick={DashboardService.initializeDashboard}>
  Open Dashboard
</button>
```

Forbidden:

* Calling effects
* Calling domain commands
* Coordinating multi-step logic
* Branching on implicit state
* “Helping” the workflow along

---

## Tightened Constraints (New in Demo 3)

Compared to earlier demos:

* UI components may **not** call domain commands
* UI components may **not** coordinate multi-step logic
* Entity domains may **not** encode process state
* Services may **not** store local state
* Effects may **not** call other effects
* Cross-domain coordination may **only** occur in services
* Workflows must be **atomic from the UI’s perspective**

Violations should feel *awkward* to implement.

---

## Success Criteria

This demo is successful when:

* Entity state and process state remain strictly separated
* The dashboard never renders with partial data
* Failure leaves the system in a clean, explainable state
* Retry behavior is obvious and deterministic
* The workflow is traceable end-to-end
* Codex can implement the system without guessing intent

If this demo feels constraining, that is expected. The constraint *is the feature*.

---

## Notes for Codex

* Treat the framework spec as law
* Prefer explicit code over reuse
* Do not invent shortcuts
* If something feels repetitive, keep it anyway
* Stop when the architecture is clear, not when it is small
