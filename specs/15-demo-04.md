# Demo 4: Progressive, Non-Atomic Workflow (Explicitly Inconsistent)

## Goal

Demonstrate how the framework supports **intentional non-atomic workflows** while remaining:

* Inspectable
* Explainable
* Safe for agentic modification

This demo deliberately relaxes the atomic guarantees established in Demo 3. In exchange, it introduces **explicit, governed structure** for partial, stale, and concurrent state.

> **This demo is not about convenience.**
> It is about making inconsistency *visible, named, and controlled*.

---

## Core Invariant

**If atomicity is abandoned, consistency must still be designed.**

The system must never rely on:

* Implicit “eventual consistency”
* UI-level guesses about freshness or completeness
* Timing-based coincidence

Every intermediate state must be **intentional, observable, and explainable**.

---

## Functional Scenario

### “Search-As-You-Type with Progressive Results”

The user types into a search box.

The application must:

1. Accept user input continuously
2. Debounce outgoing search requests (timing intentionally unspecified)
3. Allow previous results to remain visible while new results are loading
4. Explicitly mark visible results as **fresh or stale**
5. Track and expose the **number of in-flight requests**
6. Prevent older, slower responses from overwriting newer intent
7. Treat empty input as **intent withdrawal**, fully resetting state

The UI is allowed to render **partial and stale data**, but only when the state explicitly declares it.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework (authoritative spec)
* **Async Simulation:** Mocked search API (`setTimeout`)
* **Styling:** Plain CSS or inline styles
* **Testing:** None required

No additional libraries are allowed.

---

## Architectural Requirements

This demo must use **three state domains** and **one application service**.

Atomicity is intentionally relaxed, but **state ownership and boundaries are not**.

---

## State Domains

### 1. SearchQueryDomain (Intent State)

Represents **current user intent**, not results.

```js
{
  query: string
}
```

Commands:

* `setQuery(state, query)`

Selectors:

* `getQuery(state)`

Rules:

* Updates synchronously on every keystroke
* Does **not** trigger effects directly

---

### 2. SearchResultsDomain (Entity State)

Represents the **currently visible results**.

```js
{
  results: [],
  resultForQuery: string | null
}
```

Commands:

* `setResults(state, results, query)`
* `clearResults(state)`

Selectors:

* `getResults(state)`
* `getResultQuery(state)`
* `hasResults(state)`

Rules:

* Results are always associated with the query that produced them
* This domain **does not own freshness or concurrency semantics**

---

### 3. SearchLoadDomain (Process State)

Represents the **status, freshness, and concurrency of the search pipeline**.

```js
{
  status: "idle" | "loading",
  inFlightCount: number,
  isStale: boolean
}
```

#### Commands

* `setLoading(state)`
* `incrementInFlight(state)`
* `decrementInFlight(state)`
* `setStale(state, isStale)`
* `setIdle(state)`

**`setIdle` is authoritative and MUST:**

* Set `status` to `"idle"`
* Reset `inFlightCount` to `0`
* Reset `isStale` to `false`

#### Selectors

* `isLoading(state)`
* `getInFlightCount(state)`
* `isStale(state)`

Rules:

* `inFlightCount` must never be negative
* UI must never infer loading, staleness, or concurrency
* All freshness semantics live here, explicitly

---

## Effect Handlers

All external behavior must live here.

```js
Effects.api.search(query)
```

Behavior:

* Returns a Promise resolving to a list of results
* Fixed delay (e.g. 400–700ms)
* Deterministic timing (no randomness)

Rules:

* No state access
* No cancellation logic
* No retries
* No UI knowledge

---

## Application Service

### SearchService

This service owns **all coordination between intent, time, and results**.

> **Demo 4 rule:**
> Services may hold *ephemeral orchestration state* (e.g. debounce timers).
> This state is local, unobservable, and not shared.

#### `updateQuery(query)`

Required behavior:

1. Update `SearchQueryDomain`
2. If `query === ""`:

   * Clear results
   * Call `SearchLoadDomain.setIdle()`
   * Exit immediately
3. Mark existing results as stale (if any)
4. Debounce triggering the search request
5. Track in-flight requests explicitly
6. Ensure only the *latest intent* may populate results

Illustrative flow (not prescriptive syntax):

```js
SearchQueryDomain.commands.setQuery(query);

if (query === "") {
  SearchResultsDomain.commands.clearResults();
  SearchLoadDomain.commands.setIdle();
  return;
}

// debounce boundary lives here (timing intentionally unspecified)

SearchLoadDomain.commands.setLoading();
SearchLoadDomain.commands.setStale(true);
SearchLoadDomain.commands.incrementInFlight();

const intent = query;

try {
  const results = await Effects.api.search(intent);

  if (SearchQueryDomain.selectors.getQuery(
        SearchQueryDomain.getState()
      ) !== intent) {
    return; // superseded
  }

  SearchResultsDomain.commands.setResults(results, intent);
  SearchLoadDomain.commands.setStale(false);
} finally {
  SearchLoadDomain.commands.decrementInFlight();

  const count = SearchLoadDomain.selectors.getInFlightCount(
    SearchLoadDomain.getState()
  );

  if (count === 0) {
    SearchLoadDomain.commands.setIdle();
  }
}
```

Rules:

* Older responses are **ignored**, never applied
* Multiple overlapping requests are expected
* No domain silently repairs inconsistency

---

## UI Requirements

### SearchView

The UI layer must:

* Subscribe **only** via selectors
* Render strictly from **explicit state meaning**
* Never infer freshness, completeness, or concurrency

Required render states include:

* **Idle + no results:** Empty state
* **Loading + no results:** Loading indicator
* **Loading + stale results:** Results + “Updating…” indicator
* **Idle + fresh results:** Results
* **Stale indicator:** Must be visible
* **In-flight count:** Must be visible (e.g. “Updating — 2 requests in flight”)

Forbidden:

* Triggering effects
* Debouncing in components
* Guessing staleness
* Counting requests locally
* Comparing timestamps

---

## Tightened Constraints (Specific to Demo 4)

Compared to Demo 3:

* Atomicity is **explicitly relaxed**
* Partial rendering is **allowed but regulated**
* Staleness is **explicit state**
* Concurrency is **explicit state**
* Services may hold **ephemeral orchestration state**
* Time coordination lives in services, not UI
* No domain may silently “fix” inconsistency

Violations should feel *tempting but wrong*.

---

## Success Criteria

This demo is successful when:

* Results never silently mismatch user intent
* Stale data is visible and explainable
* In-flight request count is accurate and observable
* Older responses never overwrite newer intent
* Empty intent produces a clean, terminal state
* All inconsistency is explicitly modeled
* Codex can implement the workflow without guessing

If this demo feels stricter than typical search UIs, that is intentional.
The goal is **structural honesty**, not smoothness.

---

## Notes for Codex

* Treat partial and concurrent state as first-class
* Do not invent shortcuts
* Prefer explicit counters over inferred behavior
* If behavior feels repetitive, keep it
* Stop when every intermediate state has a name
