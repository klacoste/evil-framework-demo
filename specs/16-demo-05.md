# Demo 5 — Long-Lived State & Invalidation (Hard Reset)

## Goal

Demonstrate that the framework remains **correct and explainable over time**, not just at initialization.

This demo introduces **state invalidation** as a first-class operation and proves that:

* Authority outranks completion
* Invalidation outranks in-flight work
* The UI responds **only** to state change, never imperative cleanup

> **This demo is about revocation.**
> Not loading data — removing its right to exist.

---

## Core Invariant

**State must remain explainable over time, not just at initialization.**

When state becomes invalid:

* It must be explicitly invalidated
* All dependent state must be revoked
* The UI must update immediately as a *pure consequence of state change*

There are no “half-valid” or “mostly valid” sessions.

---

## Functional Scenario

### “Single-User Dashboard with Logout”

The application has:

* A single authenticated user at a time
* User-scoped dashboard data

The application must support:

1. Session initialization
2. Rendering authenticated, user-scoped data
3. **Explicit logout**
4. **Immediate invalidation of all user-scoped state**
5. UI transition to anonymous state without imperative cleanup

There is **no partial persistence**:

* When the session ends, all user data disappears
* No previous user data may remain visible
* Late data must never re-enter the system

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **UI Library:** React (function components only)
* **Build Tool:** Vite
* **State / Architecture:** Custom framework (authoritative spec)
* **Async Simulation:** Mock API (`setTimeout`)
* **Styling:** Plain CSS or inline styles
* **Testing:** None required

No additional libraries are allowed.

---

## Architectural Requirements

This demo must use **four state domains** and **one application service**.

This is the first demo where:

* State is explicitly **revoked**, not replaced
* Authority matters more than timing
* Late results are considered invalid by definition

---

## State Domains

### 1. AuthDomain (Session Authority)

Represents authentication state and session legitimacy.

```js
{
  status: "anonymous" | "authenticated",
  userId: string | null
}
```

Commands:

* `login(state, userId)`
* `logout(state)`

Selectors:

* `isAuthenticated(state)`
* `getUserId(state)`

Rules:

* This domain is the **single source of truth for session validity**
* Logout is a **hard boundary**, not a hint
* If this domain says “anonymous,” no user-scoped state is valid

---

### 2. UserProfileDomain (Entity State)

Represents authenticated user profile data.

```js
{
  profile: { id, name } | null
}
```

Commands:

* `setProfile(state, profile)`
* `clearProfile(state)`

Selectors:

* `getProfile(state)`
* `hasProfile(state)`

Rules:

* Profile data is **only valid while authenticated**
* This domain does not self-invalidate
* It must be explicitly cleared on invalidation

---

### 3. DashboardDataDomain (Entity State)

Represents user-specific dashboard data.

```js
{
  items: []
}
```

Commands:

* `setItems(state, items)`
* `clearItems(state)`

Selectors:

* `getItems(state)`
* `hasItems(state)`

Rules:

* Data is scoped to the active session
* This domain **must be cleared on logout or session failure**
* Late writes after invalidation are forbidden

---

### 4. SessionLoadDomain (Process State)

Represents session lifecycle only.

```js
{
  status: "idle" | "loading"
}
```

Commands:

* `setLoading(state)`
* `setIdle(state)`

Selectors:

* `isLoading(state)`

Rules:

* Purely descriptive
* No authority over validity
* UI may observe authenticated + loading as a transient state

---

## Effect Handlers

```js
Effects.api.fetchProfile(userId)
Effects.api.fetchDashboard(userId)
```

Behavior:

* Deterministic delays
* Resolve with mock data

Rules:

* No state access
* No retries
* No cancellation logic
* No UI knowledge

---

## Application Service

### SessionService

This service owns **session transitions, failure handling, and invalidation**.

> **Key Demo 5 rule:**
> Authority outranks time. Invalidation outranks completion.

The service MUST guard against late effect resolution.

---

### `initializeSession(userId)`

Responsible for establishing a valid authenticated session.

Required behavior:

1. Mark session as loading
2. Authenticate user
3. Load profile
4. Load dashboard data
5. Transition to idle

#### Failure semantics (explicit)

* If **any** effect fails:

  * The session MUST be invalidated
  * `logout()` MUST be called
* “Authenticated but missing data” is **not a valid long-lived state**
* Partial session state is forbidden

#### Concurrency / invalidation guard

* The service MUST capture a **session token / generation id**
* All effect resolutions MUST verify the token is still current
* If logout occurs mid-initialization, all later results MUST be ignored

Illustrative flow (not prescriptive syntax):

```js
const sessionToken = ++currentSessionToken;

SessionLoadDomain.commands.setLoading();
AuthDomain.commands.login(userId);

try {
  const profile = await Effects.api.fetchProfile(userId);
  if (sessionToken !== currentSessionToken) return;

  UserProfileDomain.commands.setProfile(profile);

  const items = await Effects.api.fetchDashboard(userId);
  if (sessionToken !== currentSessionToken) return;

  DashboardDataDomain.commands.setItems(items);
  SessionLoadDomain.commands.setIdle();
} catch {
  logout(); // mandatory on any failure
}
```

---

### `logout()`

**This is the critical operation.**

Logout represents **revocation of authority**, not a UI event.

Required behavior (in order):

1. Invalidate the active session token
2. Call `AuthDomain.logout()`
3. Clear **all user-scoped domains**
4. Reset process state

Illustrative flow:

```js
currentSessionToken++;

AuthDomain.commands.logout();

UserProfileDomain.commands.clearProfile();
DashboardDataDomain.commands.clearItems();

SessionLoadDomain.commands.setIdle();
```

Rules:

* No conditionals
* No “if authenticated” guards
* No UI callbacks
* Invalidation is unconditional and final

---

## UI Requirements

### AppView

The UI must:

* Subscribe **only** via selectors
* Render strictly from declared state meaning

Required render states:

* **Anonymous:** Login screen
* **Authenticated + loading:** Loading indicator
* **Authenticated + data:** Dashboard
* **After logout:** Immediate return to login screen

Forbidden:

* Imperative UI cleanup
* Manually hiding components
* Retaining previous user data
* Transitional hacks or delays

---

## Tightened Constraints (Specific to Demo 5)

Compared to Demo 4:

* State is **explicitly revoked**
* Identity may disappear
* Late data has no legitimacy
* Authority beats timing
* UI correctness depends on **invalidation**, not refresh

Violations should feel *subtle but dangerous*.

---

## Success Criteria

This demo is successful when:

* Logout immediately removes all user data from the UI
* Late responses never repopulate cleared domains
* UI transitions occur purely through state change
* No domain attempts to self-heal after invalidation
* Session failure always results in logout
* Codex can implement the workflow without guessing

---

## Notes for Codex

* Invalidation is not optional
* Clearing state is not an optimization
* Treat logout as a structural boundary
* Prefer explicit revocation over replacement
* If a domain depends on identity, it must be cleared
* Late data is invalid data
