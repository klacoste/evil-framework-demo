# Demo 6: Counter Without React (Naive DOM Render Pipeline)

## Goal

Demonstrate that React is **not required** for this framework’s architecture by rebuilding Demo 1’s counter using a **minimal, non-optimized DOM renderer**.

This demo exists to prove one thing:

> If we can subscribe to selectors and schedule re-renders predictably, we can swap the rendering layer without changing domains/services/effects.

No diffs. No Virtual DOM. No reconciliation. Just “recompute view → replace DOM subtree”.

---

## Important Clarification

This is a **new demo** implemented in its own folder.

* Do **not** modify `demos/demo-01`
* Implement this demo in `demos/demo-06`

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **Rendering:** Vanilla DOM (no React)
* **Build Tool:** Vite (no React plugin)
* **Styling:** Plain CSS (no frameworks)
* **Testing:** None required

Do not add additional libraries unless strictly necessary.

---

## Functional Requirements (Same as Demo 1)

The application displays a counter with:

* A numeric value
* Buttons to:
  * Increment
  * Decrement
  * Reset to zero
* Derived state:
  * Even/odd
  * Sign: `"positive" | "negative" | "zero"`

---

## Architectural Requirements

### 1) State Domain: `CounterDomain`

Create `CounterDomain` with the same structure and rules as Demo 1:

#### State shape

```js
{ value: number }
```

Initial state:

```js
{ value: 0 }
```

#### Commands (write operations)

* `increment(state)`
* `decrement(state)`
* `reset(state)`

Commands must be:

* Synchronous
* Pure
* Deterministic
* Side-effect-free

#### Selectors (read operations)

* `getValue(state) -> number`
* `isEven(state) -> boolean`
* `sign(state) -> "positive" | "negative" | "zero"`

Selectors must be pure and derived only from domain state.

---

### 2) Rendering Adapter (React-Free)

Implement a minimal rendering adapter that provides:

#### `mount(rootEl, viewFn)`

Mounts a view function into a DOM node.

* `viewFn` returns a DOM node (or `DocumentFragment`) representing the view.
* Rendering is done by **replacing** the subtree:
  * `rootEl.replaceChildren(nextNode)`

#### `useSelector(selectorFn)`

The view function receives `useSelector` via a context parameter:

```js
function SomeView({ useSelector }) {
  const value = useSelector(CounterDomain.selectors.getValue);
  // ...
}
```

Rules:

* Subscriptions are **explicit**: only selectors passed to `useSelector(...)` count.
* Re-render only when subscribed selector outputs change.
* Equality rule for this demo:
  * Use `Object.is(prev, next)` (acceptable upgrade from `===` that handles `NaN` cleanly).

#### Domain subscription linkage

To keep the adapter small, it’s acceptable to “tag” selector functions with their owning domain:

```js
selectorFn._domain = CounterDomain;
```

So the renderer can subscribe to exactly the domains referenced by the view’s selectors.

---

## UI Requirements (DOM)

Implement the UI using plain DOM APIs only.

Recommended view decomposition (to demonstrate selector-driven re-rendering clearly):

* `ValueView` subscribes to `getValue`
* `ParityView` subscribes to `isEven`
* `SignView` subscribes to `sign`
* `ControlsView` renders buttons and does **not** subscribe to anything

Mount these views into separate containers so each can re-render independently:

```html
<div id="value"></div>
<div id="parity"></div>
<div id="sign"></div>
<div id="controls"></div>
```

This provides an observable outcome:

* `SignView` should **not** re-render when incrementing from `1 → 2` (sign stays `"positive"`).
* `ParityView` should re-render on every increment/decrement (parity changes frequently).

### Optional (recommended) render counters

To make “what re-rendered” obvious without devtools, each view may show a small render count in the UI.

This render count must be **local to the view/mount** (not stored in domains).

---

## Forbidden (Demo 6)

* React (or any UI framework)
* Virtual DOM or diffing
* Render-time side effects (fetching, timers, persistence)
* UI code reading domain state directly (no `CounterDomain.getState()` inside views)

---

## Project Layout (Demo Folder)

Implement in `demos/demo-06`:

* `index.html`
* `src/main.js`
* `src/framework/` (or similar) containing the minimal primitives:
  * `createDomain`
  * `mount`
  * `useSelector` (exposed via `mount` context)
* `src/domains/counterDomain.js`
* `src/views/` (optional): `ValueView.js`, `ParityView.js`, `SignView.js`, `ControlsView.js`
* `README.md` (required)

Follow the existing repo conventions in the other `demos/demo-0X` folders where reasonable.

---

## README Requirements (Demo 6)

Create `demos/demo-06/README.md` that includes:

* A short statement of intent:
  * “This demo proves the framework can render without React.”
* A **basic overview** of the pipeline:
  * Commands update domain state
  * Domain notifies subscribers
  * `mount` re-evaluates selectors
  * If selector outputs changed, the view re-renders by `replaceChildren`
* A clear callout that this is a **non-optimized starting point**:
  * No diffs, no reconciliation, full subtree replacement per view/mount
* How to run:
  * `npm install`
  * `npm run dev`

---

## Success Criteria

This demo is complete when:

* Counter updates work (increment/decrement/reset)
* Derived state updates correctly (even/odd + sign)
* The UI never triggers side effects during render
* Views only re-render when their subscribed selector outputs change
* The README clearly communicates that this is a naive, non-optimized renderer

---

## Notes for Codex (gpt-5.2-codex)

* Treat the spec as law.
* Prefer explicit, boring code over abstractions.
* Keep the renderer intentionally naive (no diffing).
* If you add instrumentation (render counters), keep it local and obvious.
* Stop once the demo is correct and the architecture is clear.

