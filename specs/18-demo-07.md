# Demo 7: Offline + Conflict Resolution (Single Todo, Outbox, Versioning)

## Goal

Demonstrate a minimal but meaningful approach to:

* Offline operation (the app keeps working without the server)
* Deterministic sync when coming back online
* Version-based conflict detection
* Explicit, user-driven conflict resolution

This demo is intentionally small: **one entity**, **one edit operation**, **one conflict type**, **two resolution choices**.

---

## Important Clarification

This is a **fresh build** in its own folder.

* Do **not** modify any existing demo folders.
* Only implement inside `demos/demo-07`.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **Build Tool:** Vite
* **Rendering:** Vanilla DOM using the same minimal render pipeline as Demo 06 (no React)
* **Styling:** Plain CSS
* **Testing:** None required

No additional libraries should be introduced unless strictly necessary.

---

## Functional Scenario

The app manages a single todo:

```js
{ id: "t1", title: string, version: number }
```

Initial server todo (deterministic):

```js
{ id: "t1", title: "Buy milk", version: 1 }
```

### Required user actions

1. Toggle online/offline
2. Edit the todo title while offline (optimistic update; live as you type)
3. Simulate a deterministic server-side edit while still offline
4. Go back online and sync
5. Observe a version conflict
6. Resolve the conflict via one of two explicit choices:
   * **Use server**
   * **Keep mine** (rebase + retry)

---

## Core Concepts to Exercise

### Offline operation

* Editing works while offline because the app:
  1) applies an optimistic update to entity state
  2) appends an operation to an outbox
  3) (optionally) persists locally via a storage effect

### Conflict detection

* Each outbox op includes a `baseVersion`.
* The server rejects an op if `baseVersion !== serverTodo.version`.
* Rejection produces an explicit conflict object (no implicit merging).

### Explicit conflict resolution

Conflict resolution must be a **visible state** that the UI renders, not a hidden side effect.

---

## Domains

Implement **five** domains. Keep entity state and process state separate.

### 1) `ConnectivityDomain` (Process/Ambient)

State:

```js
{ isOnline: boolean }
```

Commands:

* `setOnline(state)`
* `setOffline(state)`

Selectors:

* `isOnline(state) -> boolean`

---

### 2) `TodoDomain` (Entity)

State:

```js
{ todo: { id: "t1", title: string, version: number } }
```

Commands:

* `setTodo(state, todo)` (replace)
* `setTitle(state, title)` (optimistic local edit; must preserve `id` + `version`)
* `setVersion(state, version)` (on successful sync)

Selectors:

* `getTodo(state)`
* `getTitle(state)`
* `getVersion(state)`

---

### 3) `OutboxDomain` (Intent Log)

State:

```js
{
  ops: Array<{
    opId: string,
    type: "patchTitle",
    todoId: "t1",
    patch: { title: string },
    baseVersion: number,
    createdAt: number
  }>
}
```

Commands:

* `enqueue(state, op)`
* `coalescePatchTitle(state, op)` (optional, recommended)
* `removeById(state, opId)`
* `clear(state)`

Selectors:

* `getOps(state)`
* `getCount(state) -> number`
* `hasOps(state) -> boolean`

Rules:

* By default, this domain is append-only except for explicit removal/clear.
* Optional: allow explicit coalescing for `patchTitle` so “live typing” does not create excessive pending ops:
  * If the latest op is `patchTitle` for `t1`, replace it with the new op (keep `opId` or create a new one; either is fine as long as behavior is deterministic).
* Ops are immutable records of user intent.

---

### 4) `SyncDomain` (Process)

State:

```js
{
  status: "idle" | "syncing" | "conflict" | "error",
  error: null | string
}
```

Commands:

* `setIdle(state)`
* `setSyncing(state)`
* `setConflict(state)`
* `setError(state, message)`

Selectors:

* `getStatus(state)`
* `isSyncing(state)`
* `hasError(state)`
* `getError(state)`

---

### 5) `ConflictDomain` (Explicit Conflict)

State:

```js
{
  conflict: null | {
    opId: string,
    baseVersion: number,
    minePatch: { title: string },
    serverTodo: { id: "t1", title: string, version: number }
  }
}
```

Commands:

* `setConflict(state, conflict)`
* `clear(state)`

Selectors:

* `getConflict(state)`
* `hasConflict(state) -> boolean`

---

## Effects (Stateless Modules)

All “outside world” work must live in effects.

### 1) Storage effects (local persistence)

Implement:

* `Effects.storage.loadSnapshot() -> Promise<null | Snapshot>`
* `Effects.storage.saveSnapshot(snapshot) -> Promise<void>`

Allowed storage:

* `localStorage` (recommended for demo simplicity)

Snapshot should be sufficient to restore:

* `TodoDomain` todo
* `OutboxDomain` ops

---

### 2) API effects (mock server)

Implement a deterministic in-memory “server” with module-scoped state:

* `Effects.api.getTodo() -> Promise<serverTodo>`
* `Effects.api.pushOps(ops) -> Promise<{ ok: true, todo: serverTodo } | { ok: false, conflict: { opId, serverTodo } }>`
* `Effects.api.simulateServerEdit() -> Promise<serverTodo>`

Rules:

* No randomness.
* Fixed delay (e.g. 200–400ms) so transitions are visible.
* `simulateServerEdit()` must deterministically change the title and increment version.
* `pushOps()` only needs to support `type: "patchTitle"` for `todoId: "t1"`.

Conflict rule (authoritative):

* If `op.baseVersion !== serverTodo.version`, return `ok: false` with conflict payload.

---

## Services (Workflows / Coordination)

UI must call services (not effects).

### 1) `BootstrapService`

`initializeApp()`

Required behavior:

1. Load snapshot from storage (if present)
2. If no snapshot:
   * Fetch the todo from the server
   * Populate `TodoDomain`
3. Always set `SyncDomain` to idle at the end

---

### 2) `ConnectivityService`

* `goOnline()`: sets online; does not auto-sync
* `goOffline()`: sets offline

---

### 3) `TodoService`

`editTitle(nextTitle)`

Required behavior:

1. Read current todo (via selector + domain `getState` outside UI is allowed in services)
2. Apply optimistic local update:
   * `TodoDomain.commands.setTitle(nextTitle)`
3. Enqueue an outbox op using the todo’s current `version` as `baseVersion`
   * Because the UI updates on every keystroke, it is **recommended** (but not required) to coalesce ops so the outbox typically contains at most 1 pending `patchTitle` op.
4. Persist snapshot (todo + outbox) via storage effect

Notes:

* Editing while online is allowed to behave the same way (still enqueue), but the demo does not need auto-sync.

---

### 4) `ServerService`

`simulateServerEdit()`

Required behavior:

* Calls `Effects.api.simulateServerEdit()` (even while offline)
* Does **not** write into local entity state directly (the point is that server changes are not locally visible until sync)

---

### 5) `SyncService`

`syncNow()`

Required behavior:

1. If offline, exit early (optionally set a user-visible error in `SyncDomain`)
2. If outbox empty, exit early (idle)
3. `SyncDomain.setSyncing()`
4. Call `Effects.api.pushOps(outboxOps)`
5. On success:
   * Update local todo `version` and (optionally) title from returned server todo
   * Remove applied op(s) from outbox (for this demo, one op at a time is fine)
   * Clear any conflict
   * Persist snapshot
   * `SyncDomain.setIdle()`
6. On conflict:
   * `SyncDomain.setConflict()`
   * `ConflictDomain.setConflict({ opId, baseVersion, minePatch, serverTodo })`
   * Do not mutate `TodoDomain` during the conflict transition

Keep the flow explicit and linear. No background sync.

---

### 6) `ConflictService`

Provide two explicit resolution actions:

#### `useServer()`

1. Replace local todo with `serverTodo` from `ConflictDomain`
2. Remove the conflicting op from the outbox
3. Clear conflict
4. Persist snapshot
5. `SyncDomain.setIdle()`

#### `keepMine()`

1. Read conflict payload from `ConflictDomain`
2. Remove the conflicting op from the outbox
3. Enqueue a new op with:
   * same `minePatch`
   * `baseVersion = serverTodo.version` (rebase)
4. Clear conflict
5. Persist snapshot
6. Call `SyncService.syncNow()` (retry)

---

## Rendering / UI (Vanilla DOM)

You may reuse the minimal rendering approach from Demo 06 (copy into Demo 07):

* `createDomain`
* `mount`
* selector subscription via `useSelector`
* `replaceChildren` per mount

### Styling guidance

Reuse Demo 06’s general look/feel (card layout, typography, muted “meta” text) so the demo reads as part of the same series. It’s fine to add a small conflict panel section and status rows specific to this demo.

### Required UI elements

* Online/offline indicator and toggle button
* Todo title input (or textarea)
* Current local todo version display
* Pending outbox count display
* Buttons:
  * “Simulate server edit”
  * “Sync now”
* Sync status display (`idle` / `syncing` / `conflict` / `error`)
* Conflict panel shown only when a conflict exists:
  * Show “Mine title” (from `minePatch`)
  * Show “Server title” + “Server version”
  * Buttons: “Use server” and “Keep mine”

UI rules:

* UI must subscribe via selectors (no direct state reads in views).
* UI must emit intent only via services (no effects in views).
* The title input must be “live”: changes propagate on each keystroke via the `input` event.

---

## Folder Layout (Demo 07)

Implement in `demos/demo-07`:

* `index.html`
* `src/main.js`
* `src/styles.css`
* `src/framework/` (renderer + primitives)
* `src/domains/` (5 domains)
* `src/effects/` (`api.js`, `storage.js`)
* `src/services/` (bootstrap, todo, sync, conflict, connectivity, server)
* `README.md`

---

## README Requirements

`demos/demo-07/README.md` must include:

* What this demo proves (offline, outbox, version conflicts, explicit resolution)
* The state model (brief list of domains)
* The workflow (edit → enqueue → sync → conflict → resolve)
* How to run:
  * `npm install`
  * `npm run dev`
* A note that the “server” is a deterministic in-memory mock

---

## Non-Goals

Do not implement:

* Multiple todos / list UIs
* Real network detection
* Sophisticated merge algorithms
* Background syncing
* Authentication
* IndexedDB (unless you prefer it; localStorage is enough)

---

## Success Criteria

This demo is complete when:

* Editing while offline updates the UI immediately and increases outbox count
* Simulating a server edit while offline does not change the local UI immediately
* Syncing after a server edit produces an explicit conflict state
* “Use server” resolves by adopting server state and clearing the outbox
* “Keep mine” resolves by rebasing and retrying sync successfully
* All orchestration lives in services; effects are stateless; domains remain pure

---

## Notes for Codex (gpt-5.2-codex)

* Treat this spec as law.
* Prefer explicit code over abstraction.
* Keep the server deterministic and reproducible.
* Keep the UI simple and focused on making state transitions obvious.
* Stop once the demo is correct and the core concepts are clearly exercised.
