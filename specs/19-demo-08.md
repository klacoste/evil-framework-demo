# Demo 8: Sync Engine Infra (IndexedDB + WebWorker + WebSocket)

## Goal

Demonstrate that the framework’s core ideals still hold when built on “real” browser infrastructure:

* **Durability:** persist state + outbox in **IndexedDB**
* **Isolation:** run sync + persistence logic in a **WebWorker**
* **Transport:** communicate with a **real WebSocket server**
* **Framework invariants stay intact:** explicit state, explicit workflows, clear ownership, debuggable transitions

This demo is intentionally small. The point is not a production sync engine; the point is **clean boundaries** and **predictable behavior** when the environment becomes asynchronous.

---

## Important Clarification

This is a **new demo** implemented in its own folder.

* Do **not** modify any existing demo folders.
* Implement this demo only in `demos/demo-08`.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **Build Tool:** Vite
* **Rendering:** Vanilla DOM using the same minimal render pipeline as Demo 06/07 (no React)
* **Browser APIs:** IndexedDB, WebWorker, WebSocket
* **Server:** Node.js + a minimal WebSocket server
* **Testing:** none required (but a short manual checklist is required)

Do not add libraries unless strictly necessary.

* Acceptable: `ws` for the Node WebSocket server (Node does not ship a stable built-in WebSocket server).
* Not required: CRDTs (explicitly out of scope).

---

## Functional Scenario

The app manages a single todo:

```js
{ id: "t1", title: string, version: number }
```

The server stores the authoritative todo (deterministic initial state):

```js
{ id: "t1", title: "Buy milk", version: 1 }
```

### Required user actions

1. Toggle online/offline (app-level)
2. **Explicitly connect** to the server (no auto-connect)
3. Edit the todo title while offline (optimistic update; live as you type)
4. Trigger a deterministic server edit from **another client** (second tab)
5. Go back online, connect, and observe **automatic sync**
6. Observe an explicit version conflict
7. Resolve the conflict via one of two explicit choices:
   * **Use server**
   * **Keep mine** (rebase + retry)
8. Refresh the page while offline and confirm:
   * local title + outbox survive reload (IndexedDB durability)

---

## Non-Goals (Explicit)

* CRDT usage, merge algorithms, or “conflicts disappear automatically”
* Multi-entity replication, paging, schema migrations
* Background auto-sync “magic” without an explicit, documented policy (auto-sync is allowed, but must be explainable and visible in state)
* Cross-tab shared local database coordination (each tab is its own client)

---

## Architectural Boundary (The Whole Point of Demo 8)

### UI thread responsibilities (Framework land)

* Domains own UI-facing state
* Views subscribe via selectors; **no side effects in render**
* Services orchestrate workflows and call into effects

### Worker responsibilities (Infra land)

The worker is an **effect subsystem** that owns:

* IndexedDB reads/writes
* WebSocket connection lifecycle
* Sync execution (draining outbox, retries only if explicitly asked for)
* Receiving server pushes and converting them into explicit events

### Forbidden

* Views importing/using IndexedDB, WebSocket, or Worker APIs directly
* Services touching IndexedDB or WebSocket directly (must go through the worker adapter)
* Implicit “reactive DB” subscriptions that re-render UI without named workflow steps

---

## Domains (UI Thread)

Reuse the same conceptual domains as Demo 07, but treat them as **projections** updated via explicit worker events.

Implement (minimum):

### 1) `ConnectivityDomain` (Process)

State:

```js
{ isOnline: boolean }
```

### 2) `TodoDomain` (Entity)

State:

```js
{ todo: { id: "t1", title: string, version: number } }
```

### 3) `OutboxDomain` (Intent Log Projection)

State:

```js
{
  ops: Array<{
    opId: string,
    type: "patchTitle",
    todoId: "t1",
    patch: { title: string },
    baseVersion: number,
    createdAt: number
  }>
}
```

Note: The worker is the durable owner of the outbox; UI mirrors it for rendering/debuggability.

### 4) `SyncDomain` (Process)

State:

```js
{
  status: "booting" | "idle" | "offline" | "connecting" | "syncing" | "conflict" | "error",
  isConnected: boolean,
  error: null | string
}
```

### 5) `ConflictDomain` (Explicit Conflict)

State:

```js
{
  conflict: null | {
    opId: string,
    baseVersion: number,
    minePatch: { title: string },
    serverTodo: { id: "t1", title: string, version: number }
  }
}
```

---

## Worker Interface (Strict, Versioned Message Protocol)

This demo must use a small, explicit message protocol between UI and worker.

### Message envelope (required)

All messages, in both directions:

```js
{
  v: 1,
  type: string,
  requestId?: string,
  payload?: any
}
```

Rules:

* Unknown `type` must be ignored (or produce a user-visible `error` event).
* Any request expecting a reply must include `requestId`.
* Worker must never call DOM APIs (obvious, but state it).

### UI → Worker commands (minimum)

* `engine/init` — includes `clientId` (stable per tab via `sessionStorage`)
* `engine/setOnline` — `{ isOnline: boolean }`
* `engine/connect` — explicit; opens WebSocket if `isOnline === true`
* `engine/disconnect` — explicit; closes WebSocket if connected
* `engine/loadSnapshot` — request persisted `{ todo, outbox }`
* `engine/enqueuePatchTitle` — `{ opId, title, baseVersion, createdAt }`
* `engine/syncNow` — optional manual trigger (debug), but the engine should auto-sync while connected
* `engine/resolve/useServer` — uses server todo, drops conflicting op
* `engine/resolve/keepMine` — rebases patch onto server version, re-enqueues, retries sync

### Worker → UI events (minimum)

* `engine/status` — `{ status, isConnected, error? }`
* `engine/snapshot` — `{ todo, outbox }` (after load and after any durable change)
* `engine/conflict` — `{ conflict }`
* `engine/serverTodo` — `{ todo }` (last known server state; can be used for “server meta” display)

---

## Worker Data Model (IndexedDB)

The worker persists state in IndexedDB for durability across reload.

Constraints to keep this agent-friendly:

* Use a **single database per client tab** (namespace by `clientId`), e.g. `demo-08-${clientId}`.
* Use a minimal schema:
  * `kv` store with keys: `"todo"`, `"outbox"`
  * Or separate stores (`todo`, `outbox`) — either is acceptable, but keep it small.
* Persistence must be explicit:
  * After enqueuing an op, the durable outbox must be written before emitting `engine/snapshot`.

---

## Server (Node WebSocket) Requirements

Create a minimal server process for the demo.

State:

```js
let serverTodo = { id: "t1", title: "Buy milk", version: 1 };
```

Rules:

* Deterministic “server edit”:
  * `title = `${title} (server edit)``
  * `version = version + 1`
* Conflict rule (authoritative):
  * If `op.baseVersion !== serverTodo.version`, reply with a conflict payload containing `{ opId, serverTodo }`.
* If accepted:
  * Apply the patch, increment version, reply with `{ ok: true, todo: serverTodo }`.
* Broadcast:
  * When the server todo changes, broadcast the new server todo to all connected clients (push semantics).

Client → server messages (minimum):

* `{ type: "pushOps", ops: Array<op> }`
* `{ type: "simulateServerEdit" }` (deterministic edit; useful for multi-tab demo)

Server → client messages (minimum):

* `{ type: "serverTodo", todo }` (send immediately on connect, and broadcast on changes)

---

## Required UI (Views)

Reuse Demo 06/07 look and the same “card” layout style.

Minimum UI:

* Connectivity card:
  * Online/offline toggle
  * Explicit connect/disconnect controls
  * Worker/engine status text
* Todo card:
  * Title input (disabled during `syncing` or `conflict`)
  * Local version display
* Outbox card:
  * Pending ops count and list (opId, baseVersion, patch.title)
* Sync controls:
  * “Sync now” button (optional / debug; auto-sync is the default while connected)
* Conflict panel (visible state):
  * Show “Mine” title vs “Server” title + server version
  * Actions: “Use server” / “Keep mine”
* Server meta (optional but recommended):
  * “Last known server title/version” so server pushes are observable
  * “Simulate server edit” button (sends `simulateServerEdit` to the server)

---

## Workflow Requirements (Named, Debuggable)

### Boot

1. UI creates worker and sends `engine/init`
2. UI requests `engine/loadSnapshot`
3. Worker responds with `engine/snapshot`:
   * If no data exists: return the default todo and empty outbox
4. UI sets domains accordingly and sets:
   * `SyncDomain.status = "idle"`
   * `SyncDomain.isConnected = false`
   * (Connectivity is a separate user-controlled toggle)

### Connect / Disconnect (explicit)

* `setOnline(false)`:
  1. Mark offline
  2. Close WebSocket if connected
  3. Emit `engine/status { status: "offline", isConnected: false }`

* `setOnline(true)`:
  1. Mark online (does **not** connect)
  2. Emit `engine/status { status: "idle", isConnected: false }`

* `connect()`
  1. If offline: worker emits `engine/status { status: "error", isConnected: false, error: "Offline. Go online to connect." }`
  2. Else:
     * worker emits `engine/status { status: "connecting", isConnected: false }`
     * opens WebSocket
     * on open: emits `engine/status { status: "idle", isConnected: true }`
     * on close: emits `engine/status { status: "idle", isConnected: false }` (or `"offline"` if currently offline)

* `disconnect()`
  1. Close WebSocket (if open)
  2. Emit `engine/status { status: "idle", isConnected: false }`

### Edit title (online or offline)

1. UI optimistically updates `TodoDomain.title` on each keystroke
2. UI sends `engine/enqueuePatchTitle` (recommended: coalesce so outbox stays ~1 op)
3. Worker persists outbox to IndexedDB and emits `engine/snapshot` with updated outbox
4. If `isOnline === true` and `isConnected === true` and not in conflict, worker schedules an **auto-sync** (debounced; deterministic delay is fine).

### Auto-sync policy (explicit, not “magic”)

Auto-sync is enabled whenever the engine is both **online** and **connected**.

Triggers:

* After `engine/enqueuePatchTitle` (debounced)
* Immediately after a successful `connect()` (if outbox has ops)
* Immediately after “Keep mine” rebases (as part of the named resolution workflow)

Rules:

1. If offline: do nothing and emit `engine/status { status: "offline", isConnected: false }` (no retries)
2. If disconnected: do nothing (auto-sync is only while connected)
3. If outbox empty: keep `idle`
4. If online + connected + ops exist:
   * set `syncing`
   * send ops to server (one op at a time is fine)
   * on success:
     * update persisted todo + outbox (remove applied op)
     * emit `engine/snapshot` and `engine/status { status: "idle", isConnected: true }`
   * on conflict:
     * do not mutate local todo automatically
     * emit `engine/conflict` and `engine/status { status: "conflict", isConnected: true }`

### Receiving server pushes (catch-up behavior)

When the worker receives `{ type: "serverTodo", todo }` from the server:

* Always emit `engine/serverTodo` so the UI can display “Last known server”.
* If outbox is empty and the engine is not in conflict, the worker should:
  * replace the persisted local todo with `todo`
  * emit `engine/snapshot`

This ensures that a freshly connected tab (with no pending local edits) will “pull” the latest server version immediately without requiring a manual sync.

### Resolve conflict

* **Use server**
  1. Replace persisted local todo with `serverTodo`
  2. Remove conflicting op from outbox
  3. Clear conflict, emit snapshot + idle

* **Keep mine**
  1. Remove conflicting op from outbox
  2. Re-enqueue the patch with `baseVersion = serverTodo.version` (rebase)
  3. Clear conflict
  4. Immediately run a sync again (as part of this named workflow)

---

## Agent-Friendly Constraints (Intentionally Reduce Hard Classes of Bugs)

To keep this demo maintainable under agentic edits:

* **Single ownership rule:** only the worker reads/writes IndexedDB and touches WebSocket APIs.
* **No unbounded retries:** auto-sync happens only on the explicit triggers defined above; if a sync attempt fails, the engine must surface a visible error state and wait for a user action (e.g. reconnect) rather than retrying forever in the background.
* **Idempotency rule:** every outbox op has a stable `opId`. The server must treat `opId` as idempotent (duplicate ops should not double-apply).
* **Event-sourcing mindset:** worker emits explicit events; UI updates domains only in response to those events or explicit user intent.
* **No implicit subscriptions:** no “DB listeners” or “socket listeners” inside views; only selector subscriptions.
* **Deterministic delays:** if you simulate network delay, keep it fixed (no randomness).

---

## Project Layout (Demo Folder)

Implement in `demos/demo-08`:

* `index.html`
* `src/main.js`
* `src/framework/` (copy from Demo 06/07, but do not modify those demos)
* `src/domains/` (the five domains above)
* `src/services/`
  * `bootstrapService.js` (init worker + load snapshot)
  * `todoService.js` (optimistic edit + enqueue)
  * `syncService.js` (calls `engine/syncNow`)
  * `conflictService.js` (calls resolve commands)
  * `connectivityService.js` (toggle online/offline)
  * `engineService.js` (the worker adapter; the only UI-side code that speaks to the worker)
* `src/engine/worker.js` (the actual WebWorker entry)
* `src/engine/idb.js` (minimal IndexedDB helper used only by the worker)
* `src/engine/protocol.js` (message type constants + small validation helpers)
* `server/` (Node WebSocket server)
  * `server/index.js`
* `README.md` (required)

---

## README Requirements (Demo 8)

`demos/demo-08/README.md` must include:

* One-paragraph intent: “framework ideals over real infra”
* A boundary diagram in text:
  * UI thread (domains/services/views) vs Worker (IDB + WS)
* How to run (two processes):
  * `npm install`
  * `npm run server`
  * `npm run dev`
* Manual test checklist (below)

---

## Manual Test Checklist

1. Start server + app: local title `Buy milk`, version `1`, outbox empty, status `idle`, **disconnected**.
2. Click “Connect”: status goes `connecting → idle`, connection shows connected.
3. Type while online: local title updates immediately; outbox stays ~`1` while typing (coalesced).
4. Observe auto-sync: outbox clears; local version increments; status returns to `idle` without clicking “Sync now”.
5. Open a second tab and click “Connect” there:
   * In tab B, click “Simulate server edit”.
   * In tab A, observe “last known server” updates (server push).
6. In tab A: go offline; keep typing (outbox persists).
7. In tab B: click “Simulate server edit” again.
8. In tab A: go online → click “Connect” → observe status becomes `conflict` and conflict panel appears (auto-sync triggers).
9. Resolve:
   * “Use server” clears outbox and adopts server title/version.
   * Repeat and choose “Keep mine” rebases + retries; outbox clears; server ends with your title.
10. With pending outbox, refresh tab A while offline: todo title + outbox are restored from IndexedDB.

---

## Success Criteria

This demo is complete when:

* IndexedDB durability is observable (reload preserves outbox + local todo)
* Worker boundary is strict (no IDB/WS usage outside worker)
* WebSocket connection is real (server push is observable)
* Sync + conflict + resolution are explicit and user-driven states (no background “magic”)

---

## Open Questions (Answerable Before Implementation)

None (decided for this spec):

* Remote edit is demonstrated via a second tab.
* Connection is an explicit user action (“Connect” / “Disconnect”), not automatic.
