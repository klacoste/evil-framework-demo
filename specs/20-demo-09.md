# Demo 9: Collaborative Text (CRDT) With Explicit Boundaries

## Goal

Demonstrate an **honest CRDT-based collaboration flow** while maintaining the framework’s core ideals:

* **Explicit boundaries:** UI/domains/services do not “touch” CRDT, WebSocket, or IndexedDB directly.
* **Observable workflows:** connection, replication, and persistence are explicit state and explicit events.
* **Deterministic, inspectable behavior:** no hidden merges in the UI layer; the engine reports what happened.

This demo is intentionally small: **one shared document**, **one editable field**, **one replication protocol**.

---

## Important Clarification

This is a **new demo** implemented in its own folder.

* Do **not** modify existing demo folders.
* Implement only inside `demos/demo-09`.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **Build Tool:** Vite
* **Rendering:** Vanilla DOM using the same minimal render pipeline as Demo 06–08 (no React)
* **CRDT:** **Yjs**
* **Browser APIs:** WebWorker, IndexedDB, WebSocket
* **Server:** Node.js + minimal WebSocket server (`ws`)
* **Testing:** none required (manual checklist required)

No CRDT helper servers (e.g. `y-websocket`) for this demo. Implement a minimal “sync + broadcast” server so the protocol stays legible.

---

## Product Scenario

The app is a shared, collaborative text editor for a single document:

* One `textarea`
* Multiple tabs can connect to the same server and edit concurrently
* Changes converge across tabs without “version conflicts”

### Required user actions

1. Open **two tabs** for the app
2. In each tab, click **Connect**
3. Type in both tabs (including overlapping edits)
4. Toggle one tab offline, keep typing, then go online + connect again
5. Observe: text converges across tabs after reconnect (merge behavior)

---

## What This Demo Proves (and What It Doesn’t)

### Proves

* A CRDT engine can live behind the framework boundary (worker + effects)
* Replication is explainable through explicit engine events + explicit UI state
* Offline edits can be durable (IndexedDB) and reconcile after reconnect

### Does not attempt

* “Conflict resolution UI” like Demo 07/08 (CRDTs change the story)
* Presence, cursors, multi-user awareness
* Multi-document routing, auth, access control
* Production-grade compaction, snapshots, and protocol optimization

---

## Core Architectural Boundary (Non-Negotiable)

### UI thread (Framework land)

* Domains own UI-facing state (text, connection status, counters, event feed)
* Views subscribe via selectors; **no side effects in render**
* Services orchestrate and call a single worker adapter (`EngineService`)

### Worker (CRDT engine land)

The worker is the only place allowed to:

* Import and mutate the CRDT document (Yjs)
* Talk to WebSocket APIs
* Read/write IndexedDB
* Manage replication state machine (connect/disconnect, handshake, send/receive updates)

### Forbidden

* Views importing Yjs, IndexedDB, WebSocket, or Worker APIs
* Services using WebSocket or IndexedDB directly
* “Reactive” listeners in the UI layer that implicitly drive rendering

---

## CRDT Model (Yjs)

Use a single Yjs document and a single shared text type:

* `doc = new Y.Doc()`
* `text = doc.getText("title")`

The UI’s `textarea` value is always a projection of `text.toString()`.

### Deterministic local edit rule (agent-friendly)

The UI sends **string intents** to the worker:

* `engine/setText` with `{ nextText: string }`

The worker applies edits to `Y.Text` using a deterministic diff:

* Find longest common prefix + suffix
* Delete the differing middle range, insert the new middle range

This keeps “what changed” easy to reason about and avoids the “delete all + insert all” anti-pattern.

---

## Domains (UI Thread)

Keep domains small and explicit. Suggested minimum:

### 1) `ConnectivityDomain`

```js
{ isOnline: boolean }
```

### 2) `EngineDomain`

```js
{
  status: "booting" | "idle" | "offline" | "connecting" | "connected" | "error",
  isConnected: boolean,
  clientId: string,
  error: null | string
}
```

### 3) `DocDomain`

```js
{ text: string }
```

### 4) `StatsDomain`

```js
{
  localTransactions: number,
  outboundQueued: number,
  outboundSent: number,
  inboundReceived: number,
  remoteApplied: number,
  lastServerSeenAt: null | number
}
```

### 5) `EventLogDomain` (bounded)

Maintain a small ring buffer (e.g. last 25 events):

```js
{
  events: Array<{
    at: number,
    type:
      | "BOOT"
      | "CONNECT"
      | "DISCONNECT"
      | "LOCAL_TX"
      | "QUEUE_OUTBOUND"
      | "SEND_UPDATE"
      | "RECV_UPDATE"
      | "APPLY_REMOTE"
      | "PERSIST"
      | "LOAD"
      | "ERROR",
    detail?: string
  }>
}
```

Rule: this log is for observability only; it must be bounded and not become a second state store.

---

## UI Requirements (Views)

Minimal UI:

* Connectivity + connection controls:
  * Online/offline toggle (app-level)
  * Connect / Disconnect buttons (explicit; no auto-connect)
  * Status text + last error
* Main editor:
  * Single `textarea`
* Observability panel:
  * Stats counters (from `StatsDomain`)
  * Event feed list (from `EventLogDomain`)

The editor remains usable while offline; changes reconcile after reconnect.

---

## Worker Interface (Strict, Versioned Message Protocol)

All messages in both directions:

```js
{
  v: 1,
  type: string,
  requestId?: string,
  payload?: any
}
```

### UI → Worker commands (minimum)

* `engine/init` — `{ clientId }` (stable per tab via `sessionStorage`)
* `engine/load` — load persisted CRDT snapshot (IndexedDB)
* `engine/setOnline` — `{ isOnline: boolean }`
* `engine/connect` — explicit; opens WS and performs CRDT handshake
* `engine/disconnect` — explicit
* `engine/setText` — `{ nextText: string }`

### Worker → UI events (minimum)

* `engine/status` — `{ status, isConnected, error? }`
* `engine/doc` — `{ text: string }` (current projection)
* `engine/stats` — full `StatsDomain` payload
* `engine/event` — one event to append to `EventLogDomain`

Rules:

* UI updates domains only from these events + direct user intent.
* The worker must never require the UI to infer state from timing.

---

## IndexedDB Persistence (Worker-only)

Persist the CRDT document for offline durability.

Constraints:

* Store a single binary snapshot under one key (e.g. `"yjsSnapshot"`)
* Use debounced persistence (deterministic delay) so typing doesn’t write on every keystroke
* On boot:
  * load snapshot (if present) and apply to the doc
  * emit `engine/doc` and a `LOAD` event

Remote updates must also schedule the same debounced snapshot write (durability applies to the whole replicated state, not just local edits).

Note: for this demo, snapshot-only persistence is acceptable (no incremental update log required).

---

## WebSocket Server (Node) Requirements

Implement a minimal CRDT relay server in `demos/demo-09/server`.

### Server port (avoid collisions with Demo 08)

Demo 09 must use a different port than Demo 08.

* Demo 08 server: `ws://localhost:8080`
* Demo 09 server: **`ws://localhost:8081`**

Server responsibilities:

* Hold a single in-memory `Y.Doc` for the shared document
* On connect:
  * send the server’s current CRDT state to the client (see protocol below)
* On message:
  * apply client updates to the server doc
  * broadcast updates to all other clients

No persistence is required on the server (restart resets the doc).

---

## CRDT Replication Protocol (Simple + Legible)

Use message types that are easy to debug in logs and safe for agents.

All CRDT payloads are base64-encoded Yjs updates/state vectors:

* `svB64`: `Y.encodeStateVector(doc)`
* `updateB64`: `Y.encodeStateAsUpdate(doc, sv?)`

### Handshake (on connect)

1. Client → Server: `hello`
   * `{ type: "hello", clientId, svB64 }`
2. Server → Client: `welcome`
   * `{ type: "welcome", svB64, updateB64 }`
   * Where `updateB64 = encodeStateAsUpdate(serverDoc, clientSv)`
3. Client → Server: `clientUpdate`
   * `{ type: "clientUpdate", updateB64 }`
   * Where `updateB64 = encodeStateAsUpdate(clientDoc, serverSv)`

After this, both sides are synchronized (for a single-doc demo).

### Connection status semantics (explicit)

To keep “connected” meaningful (and avoid timing inference):

* The worker must set `status = "connecting"` immediately when the Connect action begins (before WS open).
* The worker must only set `status = "connected"` **after** the handshake completes:
  * after applying the `welcome` update to the client doc, and
  * after sending `clientUpdate` to the server.

### Steady-state updates

* Client → Server: `{ type: "update", updateB64 }` (local changes while connected)
* Server → Clients (broadcast): `{ type: "update", updateB64, from: clientId }`

### Loop prevention rule (must be explicit)

The worker must not re-send remote-applied updates back to the server.

Implementation hint:

* Use the `origin` parameter in Yjs update handlers:
  * Apply remote updates with `origin = "remote"`
  * Only transmit updates whose origin is `"local"`

---

## Engine Workflow Requirements (Worker)

### Boot

1. `engine/init` sets `clientId` and initializes the Yjs doc
2. `engine/load` loads and applies the persisted snapshot
3. Worker emits:
   * `engine/status booting → idle/offline`
   * `engine/doc` (initial text)
   * `engine/stats` (zeroed)
   * `engine/event` (`BOOT`, `LOAD`)

### Local edits

1. UI sends `engine/setText(nextText)`
2. Worker computes deterministic diff and applies a Yjs transaction with `origin = "local"`
3. Worker:
   * emits `engine/doc` (new projection)
   * increments `localTransactions`
   * if connected, transmits the update immediately
   * if disconnected, increments `outboundQueued` (conceptual queue; see below)
4. Worker persists snapshot (debounced) and emits `PERSIST` event

### Offline queue (conceptual, explicit)

Because the doc is durable and the handshake is state-vector-based, “queued outbound updates” can be represented explicitly as:

* `outboundQueued`: increments when a local transaction happens while disconnected
* On reconnect + successful handshake: reset `outboundQueued` to `0`

(This is not a byte-perfect queue; it’s an explicit, user-visible indicator of “unsent local work”.)

### Remote updates

When receiving `{ type: "update" }`:

* increment `inboundReceived`
* apply to local doc with `origin = "remote"`
* emit `engine/doc` and a `APPLY_REMOTE` event
* increment `remoteApplied`
* schedule debounced snapshot persistence and emit a `PERSIST` event (same mechanism as local edits)

---

## Stats and Observability Semantics

Handshake traffic should be visible for debugging.

* Handshake messages may count toward `inboundReceived` / `outboundSent`.
* If counted, the event log must disambiguate with event `detail`, e.g.:
  * `RECV_UPDATE (handshake)`
  * `SEND_UPDATE (handshake)`
  * `RECV_UPDATE (steady-state)`
  * `SEND_UPDATE (steady-state)`

---

## Agent-Friendly Constraints (Reduce Common CRDT Pitfalls)

* **Single Yjs doc / single Y.Text** (no nested schema, no awareness)
* **Worker is the only CRDT owner** (no dual source of truth)
* **Deterministic diff for local edits** (prefix/suffix)
* **Bounded observability** (ring buffer; counters only)
* **No hidden auto-connect** (explicit connect/disconnect)
* **No server persistence** (keep failure modes simple for a demo)

---

## Project Layout (Demo Folder)

Implement in `demos/demo-09`:

* `index.html`
* `src/main.js`
* `src/framework/` (copy from Demo 06–08; do not modify other demos)
* `src/domains/` (domains above)
* `src/views/` (editor + status + stats + event log)
* `src/services/`
  * `bootstrapService.js`
  * `engineService.js` (worker adapter; the only UI-side worker API)
  * `connectivityService.js`
  * `docService.js` (textarea intent → `engine/setText`)
* `src/engine/`
  * `worker.js` (Yjs + IDB + WS)
  * `idb.js` (minimal snapshot storage)
  * `protocol.js` (UI↔worker message types + validation)
  * `crdt.js` (optional helper: diff + Yjs helpers)
* `server/index.js` (Node WS server + Yjs doc)
* `README.md` (required)

---

## README Requirements (Demo 9)

`demos/demo-09/README.md` must include:

* Intent: “honest CRDT collaboration with explicit boundaries”
* The boundary statement:
  * UI thread = framework, worker = CRDT engine
* How to run (two processes):
  * `npm install`
  * `npm run server`
  * `npm run dev`
* A short “how to demo” walkthrough (two tabs)

---

## Manual Test Checklist

1. Start server + app: status `idle`, disconnected, textarea loads (possibly empty).
2. Click “Connect” in Tab A:
   * status `connecting → connected`
   * event log shows `CONNECT`
3. Type “hello” in Tab A:
   * Tab A shows text immediately
4. Click “Connect” in Tab B:
   * Tab B receives the current text (handshake)
5. Type in both tabs concurrently:
   * text converges in both tabs within a moment (merge behavior)
6. In Tab A: toggle offline, keep typing.
7. In Tab B: keep typing while online.
8. In Tab A: toggle online and click “Connect”:
   * text converges after handshake
   * stats/event log reflect remote updates and reconciliation
9. Refresh Tab A while offline:
   * textarea restores from IndexedDB snapshot

---

## Success Criteria

This demo is complete when:

* Two tabs can edit the same text and converge (CRDT behavior)
* Offline edits survive refresh (IndexedDB snapshot)
* The UI layer remains side-effect free (worker owns CRDT/WS/IDB)
* Replication is observable via explicit status + counters + bounded event feed
