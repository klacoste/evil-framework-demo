# Demo 10: Safer Renderer (Template Parts + Explicit Subscriptions)

## Goal

Rebuild Demo 6’s counter without React, but replace the “full subtree replacement” renderer with a renderer that addresses the reviewer’s notes while staying **dumb**, explicit, and maintainable:

* **Inputs work:** focus, cursor position, and selection are not lost on updates.
* **No event leaks:** event listeners are not duplicated across updates; unmount cleans up.
* **Less imperative DOM code:** views use small declarative templates (no VDOM, no diffing).
* **Still framework-shaped:** selector subscriptions remain explicit and observable.

This demo exists to prove a stronger invariant than Demo 6:

> Rendering can be incremental and safe (stable nodes + parts updates) without introducing a magical UI framework.

---

## Important Clarification

This is a **new demo** implemented in its own folder.

* Do **not** modify `demos/demo-06`.
* Implement this demo only in `demos/demo-10`.

---

## Tech Stack

* **Language:** JavaScript (ES2020+)
* **Build Tool:** Vite
* **Rendering:** Vanilla DOM + custom template-parts renderer (no React)
* **Styling:** Plain CSS
* **Testing:** none required (manual checklist required)

No third-party rendering libraries (no Solid/Svelte/Lit). The point is to implement a small, auditable adapter.

---

## Functional Requirements (Counter)

Same user-facing behavior as Demo 6:

* Display current counter value
* Buttons:
  * Increment
  * Decrement
  * Reset to zero
* Derived state:
  * Even/odd
  * Sign: `"positive" | "negative" | "zero"`

### Additional requirement (to prove input safety)

Add a controlled input for the counter value:

* An `<input>` showing the current value
* Typing updates the counter (parse as integer; invalid/empty input should not throw)

This input is the primary regression test for “no focus/selection loss”.

---

## Architectural Requirements

### 1) State Domain: `CounterDomain`

Same as Demo 6, plus a `setValue` command for the input.

State:

```js
{ value: number }
```

Commands (pure, deterministic, synchronous):

* `increment(state)`
* `decrement(state)`
* `reset(state)`
* `setValue(state, value: number)`

Selectors:

* `getValue(state) -> number`
* `isEven(state) -> boolean`
* `sign(state) -> "positive" | "negative" | "zero"`

---

## Renderer Requirements (The Main Work)

### Core idea: template parts, not subtree replacement

Instead of `rootEl.replaceChildren(...)` on every update, the renderer must:

1. Create DOM nodes once from a static template
2. Track **parts** (dynamic holes)
3. On update, only update the parts whose values changed

No Virtual DOM and no general diffing of arbitrary trees—only explicit parts.

### Public API (minimum)

Implement a small rendering adapter:

#### `html\`...\``

A tagged template that returns a `TemplateResult`:

```js
const view = (state) => html`<p>Value: ${state.value}</p>`;
```

#### `render(templateResult, container, scope)`

Renders a `TemplateResult` into a container.

* First render: instantiate template, create parts, append DOM.
* Subsequent renders: reuse the existing instance and update parts.

`scope` is a per-mount object that provides cleanup hooks (see below).

#### `mount(rootEl, viewFn)`

Similar to Demo 6, but instead of returning a DOM node, `viewFn` returns a `TemplateResult`:

```js
mount(rootEl, ({ useSelector, renderCount }) => {
  const value = useSelector(CounterDomain.selectors.getValue);
  return html`<div>...</div>`;
});
```

Update rules:

* Subscriptions are explicit: only selectors passed to `useSelector(...)` count.
* On domain change:
  * if any subscribed selector outputs changed (`Object.is`), call `viewFn(...)` again and `render(...)`.
* `mount(...)` must return a disposer that:
  * unsubscribes from domains
  * tears down renderer resources (events, timers, etc.)

This preserves Demo 6’s “selector-driven update model” but changes the render backend.

---

## Template Binding Features (Minimum Set)

Support a minimal, legible binding surface inspired by Lit syntax:

### 1) Text parts

```js
html`<p>${value}</p>`
```

Updates text content without replacing surrounding nodes.

### 2) Attribute parts

```js
html`<div class=${className}></div>`
```

### 3) Property parts (required for inputs)

```js
html`<input .value=${String(value)} />`
```

Must update `el.value` without recreating the element.

### 4) Boolean attribute parts

```js
html`<button ?disabled=${isDisabled}>...</button>`
```

### 5) Event parts (must not leak)

```js
html`<button @click=${handler}>...</button>`
```

Rules:

* Updates must not accumulate multiple listeners for the same element/event.
* Disposing a mount must remove all event listeners created by that mount.

Implementation constraint (agent-friendly):

* It is acceptable (recommended) to implement events using a per-mount `AbortController`:
  * Add listeners with `{ signal: abortController.signal }`
  * Abort on dispose
* Updating an event part should update the **current handler reference** without adding a new DOM listener.

### Optional (not required)

* Array children, directives, keyed repeats, etc. are not required for this demo.

---

## Input Safety Requirements (Focus + Cursor + Selection)

When updating `.value` on `<input>` or `<textarea>`:

* Do not replace the element.
* If the element is focused:
  * preserve `selectionStart` / `selectionEnd` when possible
  * avoid rewriting `.value` if it is already equal (to reduce caret jumps)

Manual validation must be possible with the checklist below.

---

## Observability Requirements (Keep Renderer “Dumb”)

The renderer must remain inspectable and boring:

* No hidden dependency tracking at render time
* No implicit side effects
* No lifecycle hooks beyond `mount()` + disposer
* Parts must be explicit objects (e.g. `TextPart`, `AttrPart`, `PropPart`, `EventPart`)

Recommended: expose a tiny debug counter in `mount`:

* `renderCount` increments every time `viewFn` runs and is passed into the view
* Display it in the UI as “Render cycles” so it’s obvious updates are happening without DOM replacement

---

## Demo UI Requirements

Build a single-page UI (card layout is fine) that includes:

* Counter value display
* Even/odd display
* Sign display
* Buttons: increment/decrement/reset
* Controlled value input (shows and edits value)
* “Render cycles” display (local, not stored in domain)

---

## Forbidden (Demo 10)

* React or other UI frameworks
* Full subtree replacement on updates (`replaceChildren` as the update mechanism)
* Virtual DOM diffing / reconciliation engines
* Implicit reactive dependency collection (no “track deps automatically during render”)

---

## Project Layout (Demo Folder)

Implement in `demos/demo-10`:

* `index.html`
* `src/main.js`
* `src/framework/`
  * `createDomain.js` (copy from Demo 06/07; do not modify those demos)
  * `mount.js` (new behavior: template render + disposer)
  * `useSelector.js` (same idea as Demo 06)
  * `renderer/` (or similar)
    * `html.js` (tag + TemplateResult)
    * `render.js` (template instance + parts update)
    * `parts.js` (Text/Attr/Prop/BoolAttr/Event parts)
* `src/domains/counterDomain.js`
* `src/views/AppView.js` (recommended: one mount to maximize input safety coverage)
* `src/styles.css`
* `README.md` (required)

---

## README Requirements (Demo 10)

`demos/demo-10/README.md` must explain:

* Why Demo 6’s renderer is insufficient for real apps (inputs/events/verbosity)
* The new approach (template parts + stable nodes)
* How event cleanup works (e.g. AbortController scope)
* How `.value` updates preserve focus/selection
* How to run:
  * `npm install`
  * `npm run dev`

---

## Manual Test Checklist

1. Basic counter works: increment/decrement/reset.
2. Derived state updates: even/odd and sign.
3. **Input focus retention:**
   * Click into the value input, put cursor in the middle.
   * Click increment.
   * The input stays focused and the cursor/selection is not reset to the end.
4. **Input selection retention:**
   * Select a range of characters in the value input.
   * Click decrement.
   * The selection remains (or degrades gracefully without throwing).
5. **No event duplication:**
   * Click increment 20 times; value increases by exactly 20.
   * If listeners were being duplicated on each update, this will drift quickly.
6. Reload page:
   * App still works; no console errors.

---

## Success Criteria

This demo is complete when:

* The counter behaves like Demo 6
* Inputs remain usable under frequent updates (focus + cursor/selection preserved)
* Event listeners do not accumulate across updates and are cleaned up on dispose
* The renderer remains small, explicit, and easy to audit

